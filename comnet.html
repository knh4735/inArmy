<html lang="ko">
   <head>
	 <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.min.js"></script>
    </head>
	 
<body>
	### Internet Architecture

Protocol : 규칙, 메시지의 형식과 순서, 송*수신시 동작을 정의한다

Protocol Layering : 네트워킹을 부분 부분 나누어서 작은 일들을 처리하도록 나눔

- 프로토콜간 독립적으로 동작하도록 해서 유지 보수를 쉽도록함
- 프로토콜은 자기가 담당한 부분만하고 디테일한 부분은 하위 프로토콜에 맡김

Internet Architecture의 목표

1. 게이트웨이나 네트워크의 손실이 있어도 통신이 유지된다.
   - 패킷에 목적지 주소가 포함됨
   - 네트워크 장비에서는 스테이트 없이 포워딩만 해줌
   - Altanative : Circuit Switching (얘는 위의 특징을 못가짐. 그래서 인터넷은 패킷을 사용함)
     - Circuit : 통신 전에 연결을 세팅한 후에 그걸로만 통신함. 방해 X. 신뢰 ^, 빠름
     - Packet : 라우터에서 패킷을 큐에 갖고잇다가 포워딩해줌. 링크를 패킷들이 공유할 수 잇음. 느림. 신뢰 v
2. 다양한 형식의 통신 방식을 지원한다. (EX. TCP, UDP)
3. 여러 종류의 네트워크를 수용한다. (LTE, 3G, 유선 등 서로 연결될 수 있으며, 어플단에서 신경쓸 필요없도록 함)
4. 분산된 관리가 가능하다.
   - 네트워크 라우터, GW 들을 AS (Autonomous System)라는 독립적인 그룹으로 관리한다
   - BGP (Border Gateway Protocol)를 통해 AS들을 연결한다.
5. Cost-effective. but 프로토콜마다 잇는 패킷 헤더들이 비용(overhead)을 증가시킴. 애매함
6. 새로운 Host가 쉽게 추가될 수 있다. (IP는 꽂으면 연결되는 방식이라 간단함. 근데 Endpoint가 너무 많아져서 문제)
7. 자원 사용량의 모니터링이 가능하다.

---

### OSI 7 Layer

Protocol Stack : App > Presentation > Session > Transport > Network > Datalink > Physical

- Application Layer (패킷) : 사용자에게 나타나며, 네트워크를 통해 송*수신 할 수 있게 해줌. (EX. 브라우저, 이메일)
- Presentation Layer : 어플과 네트워크 사이의 데이터 형식 변환. (EX. Encoding, 암호화, 압축 등)
- Session Layer : 프로세스간 통신 세션을 관리함. (EX. SIP = Session Infliate Protocol (보이스톡 가튼거 할때))
  - 대화 (Dialog) 관리, 동기화, 오류 처리 등의 많은 기능이 있다.
- Transport Layer (세그먼트) : 네트워크 종류에 관계없이, 신뢰 가능한 통신하도록 함. 프로세스마다 포트를 부여, 포트를 통해 연결
  - TCP : Handshake 가튼거 하고, 신뢰 가능한 연결을 수립함. 받는 쪽에서 데이터를 다 받으면 재조립해서 상위 프로토콜로 올림. 문제가 잇으면 다시 보내라고 요청함. 느림
  - UDP : 연결 같은거 없고, 잘 받겟지 하고 그냥 보냄. 빠르지만 신뢰가 안됨
  - 주요 기능
    - 연결 관리 : 두 기기간 연결을 수립함 (TCP: 3-way Handshake를 통해 두 기기간 가상 회선을 통해 연결함)
    - Multiplexing : 포트를 통해 프로세스 별 연결을 관리한다. 소켓을 통해 App과 통신
    - Segmentation (쪼갬), Reliable/Unreliable 통신
    - Flow control : 송*수신자 사이의 처리 속도 차이 해결. 수신자의 처리 속도에 맞게 보내줌
    - Congestion Control : 네트워크 장비들의 처리 속도 차이, 트래픽 몰림 해결. 네트워크 상황에 맞게 보내줌
- Network Layer - IP (데이터그램) : Best effort delivery. 보내려고는 하겠는데 안되도 모름. 신뢰성 X
  - Internetworking : 다른 네트워크와 이어줌. (다른 프로토콜과 이어주진 않음 ex. Bluetooth <--x--> Wi-Fi)
  - Logical Addressing : 글로벌리 유니크한 논리적 주소를 통해 각 기기를 구별한다.
  - Routing : 각 라우터에서 그때그때 어떤 라우터로 보내는게 좋은지 찾아서 보냄
- Datalink Layer (프레임)  : 노드 간 신뢰 가능한 전달을 맡음. 패킷을 프레임으로 바꾸며 물리 주소와 쳌섬 등을 포함하여 전달함
  - Flow Control, Error Control 함
- Physical Layer : 전기 신호를 통해 실제로 데이터를 전송

OSI 7 Layer의 장점 : 각 프로토콜이 독립적으로 발전할 수 있고, 표준화가 가능하여 호환, 개발, 운영에 유리하다.

---

### IPv4

Class : 5개의 클래스로 나뉜다.  IP 할당이 너무 비효율적임, 라우팅도 너무 복잡함 -> CIDR 등장

|      A       |        B         |        C         |         D         |        E        |
| :----------: | :--------------: | :--------------: | :---------------: | :-------------: |
| 0~ (0 ~ 127) | 10~  (128 ~ 191) | 110~ (192 ~ 223) | 1110~ (224 ~ 239) | 1111~ (240~255) |
| 8비트 Prefix |  16비트 Prefix   |  24비트 Prefix   |   멀티캐스팅용    | For future use  |

Hierarchy : 주소 관리을 위해 계층을 둠. 라우팅에도 도움.  IANA > 지역 > 국가 (NIR) or 로컬 (LIR) > 기관 or ISP > 개별 장비

Special Address : 예약된 IP 주소

- 0.0.0.0 : IP 주소를 할당 받기 전에 Src 주소로 사용됨 (0.{Host번호} : 해당 네트워크 안에서 같은 목적의 Src로 사용됨)
- 255.255.255.255 : Broadcast. ({Network Prefix}.111... : 해당 네트워크 안에서 Broadcast)
- 127.~ : Loopback 주소
- 10.~ / 172.16.~ / 192.168.~ : Private Address. 소속된 네트워크 안에서만 유효한 주소

Packet forwarding method : Unicast, Broadcast, Multicast

CIDR : Class 안에서 subnet으로 또 쪼갬. IP주소/마스크 비트 수로 표기함.

- Subnet mask를 통해 Subnet으로 쪼개어지며, Network / Subnet / Host로 주소가 분리됨
- 마찬가지로 첫 주소와 마지막 주소(Network.Subnet.0, 11...)는 각각 대표 주소와 Broadcast 주소로 사용됨
- Subnet - 주소 관리가 효율적, 라우팅 테이블 엔트리 수도 줄어듦
- Supernet : C 클래스들을 묶어서 한 네트워크로 보이게 함. 마찬가지로 CIDR 표기로 표시함

---

### IPv6

형식 : 128비트. 16비트씩 끊어서 :로 구분함. ::는 0들을 묶은거

- 네트워크 인터페이스마다 할당될 수 있음. 한 인터페이스가 여러 주소를 가질 수 있음.
- 한 링크에 여러가지 subnet prefix가 할당될 수 있음

Packet forwarding method : Unicast, Anycast, Multicast (IPv4는 애니 대신 브로드)

- **Anycast** : 같은 Anycast 주소를 가진 노드 중 가장 가까운 친구에게 전달되도록 한다. Src로 사용 불가

  - 장점 : 트래픽 로드 밸런싱, 한 친구가 죽어도 다른 친구가 받아서 처리해 줌
  - Subnet-Router Anycast Address : 서브넷 라우터에 애니캐스트 주소를 두어서 가장 가까운 라우터를 통해서 전달되도록 함

- Unicast : 범위에 따라 분류가 나뉨.  Link-local (라우터를 안넘어가는 범위) < Unique-local (특정 지역, 사설망) < Global

  - Local-use Address : Link-local, Site-local
    - Link-local : FE80::{Modified EUI-64 Format} 
    - Site-local : IPv4의 Private 주소랑 같음. 잘안씀. FEC0:{54bit SubnetID}:{Modified EUI-64 Format}

  - Global : Public IPv4 주소처럼 글로벌에서 라우팅 가능한 주소
    - 보통, 앞 64비트 네트워크 (뒷 16 = Subnet)  / 64비트 Host 로 나뉨
    - IP 할당 : Network는 라우터가 보내주는 Network Prefix 사용 / Host는 Modified EUI-64 Format로 구성
  - Special Address
    - 0 : 아직 주소가 없을 때 Src로 사용
    - 0::1 : Loopback

- Multicast : 해당 주소의 모든 인터페이스에게 전달. Src로 사용 불가. **Broadcast는 Bandwidth을 낭비**하지만 Multi는 X

  - 노드들은 여러개의 Multicast 주소를 가질 수 있고, 언제든 그룹에 들어가거나 나올 수 있음
  - 주소 형식 : FF로 시작. 각 4비트의 Flag와 Scope 필드. 이후 112비트의 Multicast Group ID
    - Flag : 0 / Rendezvous Point Address / Prefix / Transient 순서
      - Prefix = 해당 주소가 Unicast 주소 기반 / Transient  = 임시 (IANA가 할당하지 않은) 주소인지
    - Scope : 해당 Mulicast 트래픽이 포함되는 범위 (EX. 1 = Interface-local / 2 = Link-local / 5 = Site-local)
      - Assigned Address : ~~ ::1 = 해당 범위 내의 모든 노드 / ~~::2 = 해당 범위 내의 모든 라우터
      - Interface-local : 루프백 (프로세스간 통신)

**Modified EUI-64 Format** : IP 할당을 위해 Host 부분을 자신의 MAC 주소로 구성함

- 48비트인 MAC 주소의 가운데에 FF FE를 넣어서 64비트로 바꿈
- 일반적으로 (Unique한 경우) 왼쪽에서 7번째 비트를 1로 바꿔줌

IPv4-mapped IPv6 address : IPv4 -> IPv6. 0::FF FF:{IPv4 주소}

**Solicited-Node Multicast Address** : 다음 홉의 IPv6 Unicast 주소를 통해 Layer 2 주소를 생성하는 방식

- IPv4에서는 Broadcast ARP를 통해 다음홉의 MAC 주소를 알아낸다.

- IPv6에서는 NDP (Neighbor Discovery Protocol)를 사용하여 알아낸다.

  - IPv6 Unicast 주소 뒤 24비트를 떼서 Multicast 주소를 생성하고, 이를 통해 다시 Layer 2 주소를 생성한다.

  - |         |    Unicast     |     Multicast     |
    | :-----: | :------------: | :---------------: |
    | Layer 3 | 2001:DB8::AB:2 |  FF02::1:FFAB:2   |
    | Layer 2 |                | 33-33-FF-AB-00-02 |

---

### Transport Layer

특징 : Unique Endpoint (IP + Port). TCP or UDP

- Port : 프로세스를 구분하는 논리적 번호. 프로토콜 및 IP 주소와 연관되면 Unique하다. <TCP, 1.2.3.4, 80>
  - System (Well-known 0~1023), User (Registered 1024~49151), Dynamic or Private (그 외)로 구분된다.

기능 : 포트를 통한 어플리케이션 간 통신, Multiplexing, 신뢰성, Flow control, Congestion control, Connection.

- 패킷을 받는다 - 목적지 Port 번호에 따라 맞는 Application에게 전달한다
- IP Layer에서는 IP Header의 프로토콜 필드에 따라 TCP로 전달할지 (6) / UDP로 전달할지 (17) 결정함
- **UDP** : **Dst IP와 포트 번호**를 확인하여 상위 레이어로 전달함
- **TCP** : **Dst IP, 포트 + Src IP, 포트**까지 확인하여 상위 레이어로 전달함

Socket : Application과 Transport Layer 사이의 인터페이스. TCP 또는 UDP에서 올린 패킷이 소켓의 큐에 쌓임

---

### Datalink Layer

MAC (Media Access Control) 주소 : NIC (Network Interface Card) 장비들이 갖는 6 바이트의 물리적 고유 주소

- **OUI** (organazationally Unique Identifier, 3 바이트) + **UAA** (Universally Administered Address, 3 바이트)로 구성된다.
  - OUI : 제조사마다 할당된 고유 번호. IEEE에서 제공.
    - 왼쪽에서 7번째 비트는 해당 주소가 IEEE에서 제공한게 아닌지(1)  / 8번째 비트는 Multicast (1)인지 Unicast인지이다.
  - UAA : 이거 UAA 아니고 **NIC Specific**. 즉, 제조사에서 제품에 매기는 일련번호임 피피티 이상

EtherType : Ethernet Frame에 포함된 2 바이트 크기의 필드. 어떤 프로토콜인지 표시된다.

- EX. 0x8000 = IPv4 / 0x0806 = ARP / 0x8600 = IPv6

---

### DHCP

DHCP : **IP 주소 할당**을 위한 프로토콜. Dynamic Host Configuration Protocol

- UDP를 통해 통신하는 Application layer의 프로토콜이다.
- Unique한 IP 주소의 할당 및 관리를 네트워크 관리자에 의해 중앙 관리하도록 한다.
- 클라이언트에서 별도의 재설정 없이 할당받을 수 있으며, 네트워크 관리자가 일일이 할당할 필요가 없도록 설계되었다.
- BOOTP (Bootstrap Protocol)의 확장판이다.
- IP 할당 : 자동할당 (영구적인 할당), 동적할당 (기간제 IP 할당), 수동할당이 잇다.
- **장점** : 중앙 관리, 동적 할당, 끊김 없는 IP 설정, 확장성 

과정 : Discover - Offer - Request - Acknowledge

1. Discover : IP 달라고 요구함. (Src = 0.0.0.0 / Dst = 255.255.255.255)
2. Offer : IP 주소 제안 (Src = Server IP / Dst = 255.255.255.255)
3. Request : 이거 진짜 쓴다? (Src = 0.0.0.0 / Dst = 255.255.255.255)
4. Acknowledge : ㅇㅋ 그거 써라 (Src = Server IP / Dst = 255.255.255.255)

- 여러 DHCP 서버가 Discover 패킷을 받으면, 각자 클라이언트에게 IP를 제안한다.
- 옵션 필드의 Requested IP Address에 클라이언트가가 선택한 IP주소를 박고 Offer했던 서버들에게 Request 보낸다.

Relay Agent : 라우터나 게이트웨이 등의 DHCP 패킷을 전달해주는 장비

- Broadcast 패킷은 기본적으로 라우터를 넘어가지 않도록 차단한다.
- 그러나 DHCP 패킷의 경우 라우터를 지나며 (Src = 라우터 IP / Dst = 라우터가 알고있는 DHCP 서버 주소)로 변경하여 전달한다.
- 또 서버에서는 Relay Agent에게 Unicast로 응답하고, 이를 Broadcast로 서브넷에 뿌려준다.

**Message Format**

- op : 1 = BOOTREQUEST / 2 = BOOTREPLY
- hops : 릴레이 에이전트를 지날때마다 1씩 증가
- secs : 클라이언트에서 재할당 요청시 주로 사용. IP 할당 후 지난 시간
- flags : 맨 앞 비트 : 브로드캐스트 비트. 나머지 = 0
- **options** : 3가지 필수 옵션들 + 기타 등등
  - IP 주소 Subnet Mask (code 1) : 라우팅을 위해
  - Default Gateway (code 3) : 다음 홉을 모를 때 보낼 기본 IP 주소
  - DNS 서버 IP 주소 (code 6)

<table style="text-align:center">
  <tr>
    <td>op (1)</td>
    <td>htype (1)</td>
    <td>hlen (1)</td>
    <td>hops (1)</td>
  </tr>
  <tr>
    <td colspan="4">transaction ID (4)</td>
  </tr>
  <tr>
    <td colspan="2">secs (2)</td>
    <td colspan="2">flags (2)</td>
  </tr>
  <tr>
    <td colspan="4">Client IP (4) = 현재 클라이언트의 주소</td>
  </tr>
  <tr>
    <td colspan="4"><b>Your IP</b> (4) = 할당받을, 제안받은 IP 주소</td>
  </tr>
  <tr>
    <td colspan="4">Server IP (4)</td>
  </tr>
  <tr>
    <td colspan="4">Relay Agent IP (4) = 통과한 Relay agent의 IP</td>
  </tr>
  <tr>
    <td colspan="4">chaddr (4) = Client Hardware = MAC</td>
  </tr>
  <tr>
    <td colspan="4">Server Host Name (4)</td>
  </tr>
  <tr>
    <td colspan="4"><b>Options</b> (4)</td>
  </tr>
</table>

---

### DNS

DNS : **Domain 이름을 IP 주소로 매핑**해주는 프로토콜. Domain Name System

- 도메인은 계층적으로 이루어짐
  - EX. www.naver.com = . (root) > com (Top-level Domain) > naver (Second-level Domain)> www (Subdomain)
- Endpoint에서는 **DNS Resolver**에게 쿼리를 보내고, DNS Resolver가 DNS Name Server들에게 물어물어 IP 주소를 응답한다.

**DNS Query** : Recursive 쿼리와 Iterative 쿼리로 구분된다.

- Recursive 쿼리 : End user가 Resolver에게 보내는 쿼리로, 최종적인 IP 주소를 응답받을 수 있다.
- Iterative 쿼리 : **Resolver**가 Name Server에게 보내는 쿼리로, 다음으로 질의을 보내야하는 네임 서버의 주소를 얻을 수 있다.
  - 위에 예시로 써논 순서대로 각 도메인 네임 서버에 질의를 보내게 된다. 마지막에는 IP 주소를 얻을 수 있다.
  - Resolver는 얻은 IP 주소를 캐시에 넣고, End user에게 응답해준다.

Delegation : 여러 네임서버의 존들을 묶어서 공통으로 관리하는 거

- Zone : 한 네임서버에서 관리하는 범위 (EX. naver.com에서 cafe.naver.com, www.naver.com을 관리하면 같은 Zone)

**Message Format **: Header - Question - Answer - Authority - Additional로 구성된다. Header = 12바이트. 나머진 가변길이

- 메시지가 512 바이트보다 작으면 UDP, 크면 TCP를 사용한다. DNS 메시지가 UDP 또는 TCP 패킷의 데이터로 포함된다.
- Header : 첫 2바이트는 Transaction ID / 다음(16) 비트는 (0: Query, 1: Response) / 23, 24비트는 Recursive 질의, 응답 여부

---

### IP

Identity : 기기 자체 / Identifier : 기기를 구별할 수 있게 하는 요소들. 기종, 물리주소 등

IP : Datagram을 Src -> Dst 전달함. Packet-switch 네트워크를 통해서. 긴 데이터를 쪼개 보내고, 재조립할 수 있음.

- 기본 기능 : **Addressing, Fragmentation**
- Routing : Dst까지 전달하기 위해 경로를 선택하는 작업

**Message Format** : Header (20 ~ 60 바이트) + Data

<table style="text-align:center;">
  <tr>
    <td colspan="4">Version (4)</td>
    <td colspan="4">헤더 길이 (4)</td>
    <td colspan="8">Type of Service (8)</td>
    <td colspan="16">Total Length (16)</td>
  </tr>
  <tr>
    <td colspan="16">Identification (16) = Datagram ID</td>
    <td colspan="3">Flags (3)</td>
    <td colspan="13">Fragmentation Offset (13)</td>
  </tr>
  <tr>
    <td colspan="8">TTL (8)</td>
    <td colspan="8">Protocol (8)</td>
    <td colspan="16">Header Checksum (16)</td>
  </tr>
  <tr>
    <td colspan="32">Source IP Address (32)</td>
  </tr>
  <tr>
    <td colspan="32">Destination IP Address (32)</td>
  </tr>
  <tr>
    <td colspan="32">Option + Padding IP (0 ~ 40 바이트)</td>
  </tr>
</table>

- Version : IPv4 or IPv6  /  Header Length : 4 바이트 단위  /  Total Length : 데이터를 포함한 전체 길이. 바이트 단위
- Type of Servie (Quality of the Service) : 요구되는 서비스 품질. 네트워크 혼잡 상태 정보
- Flags : 쪼갬 플래그. 2번비트 : 쪼개지마라 (받는놈이 재조립을 못한다)  /  3번비트 : 뒤에 더 조각이 있다
- Fragmentation Offset : 조각의 원래 위치 (8 바이트 단위). 쪼개져도 Id 필드는 같다.
- Time To Live : 패킷의 수명. 라우터를 지날때마다 1씩 감소. 0이 되면 버려짐. 네트워크 낭비를 막기 위함
- Protocol : 상위 레이어에서 사용된 프로토콜 종류. (1 ICMP / 6 TCP / 17 UDP)
- **Header Checksum** : 에러 검출을 위한 필드. 수신자는 쳌섬을 포함해서 쳌섬 계산을 하면 0이 나와야 받아줌
  - TTL 같은 값이 계속 바뀌기 때문에 라우터마다 다시 계산해줌
  - 계산법 : 쳌섬을 제외한 헤더를 16비트씩 쪼개서 다 더한 후 1의 보수를 구함.
- Option : 디버깅용. Source Route = 패킷의 이동 경로를 지정해줄 수 있음 / 그 외엔 안씀

**Fragmentation** : 네트워크에서 허용하는 패킷의 크기가 작은 경우에 쪼개서 보냄

- MTU (Maximum Transmit Unit) : 보낼 수 있는 Datagram의 최대 크기. (Header 크기 제외)


<div class="mermaid">
graph LR
A[Total: 4020<br>ID: 14567<br>Flag: 000<br>Offset: 0]

subgraph MTU 1400
B1[Total: 1420<br>ID: 14567<br>Flag: 001<br>Offset: 0]
B2[Total: 1420<br>ID: 14567<br>Flag: 001<br>Offset: 175]
B3[Total: 1220<br>ID: 14567<br>Flag: 000<br>Offset: 350]
end

subgraph MTU 800
C1[Total: 820<br>ID: 14567<br>Flag: 001<br>Offset: 175]
C2[Total: 620<br>ID: 14567<br>Flag: 001<br>Offset: 275]
end
A-->B1
A-->B2
A-->B3
B2-->C1
B2-->C2
</div>

**Forwarding** : Direct와 Indirect로 나뉜다. Direct = Src와 Dst가 같은 네트워크에 잇을때 / Indirect = 다른 네트워크일 때

- Direct Forwarding : 목적지가 같은 네트워크에 있는 것을 앎 -> 상대의 MAC을 구해서 Layer 2로 전달함
  - 결국 패킷에 나타나는 주소는 (Src IP = 내 IP, Dst IP = 목적지 IP / Src MAC = 내 MAC, Dst MAC = **목적지** MAC)
- Indirect Forwarding : 다른 네트워크다! -> Routing Table을 검사해서 다음 홉(라우터)의 IP를 찾고, MAC을 구함
  - 결국 패킷에 나타나는 주소는 (Src IP = 내 IP, Dst IP = 목적지 IP / Src MAC = 내 MAC, Dst MAC = **라우터** MAC)
- 과정
  1. 내가 가진 Network Interface들의 서브넷이 목적지의 서브넷과 같은 게 하나라도 있는지 찾는다.
  2. 있으면 Direct로 보냄. 없으면 Routing Table 조회 후 매칭된 쪽으로 보냄
  3. 매칭된 엔트리가 여러개면 가장 많은 마스크 비트가 매칭된 쪽. 없으면 Default GW
- Gateway Selection
  1. 일단 Default GW에 보냈는데, 얘는 자기를 거치는 경로가 최적이 아님을 알고있음
  2. 최적인 GW에게 포워드해주고, Source에게 ICMP Redirect 메시지를 보내서 Route-cache를 수정하도록 함



<div class="mermaid">
graph TD
subgraph Application
7[Application Packet]
end
subgraph Transport
4[TCP Segment]
end
subgraph Network
3[IP Datagram]
end
subgraph Datalink
2[Datalink Frame]
end
1[Physical Layer]

7-->|Socket을 통해 Data, Src IP, Dst IP, Port 전달| 4
4-->|Dst IP|3
3-->|다음 홉 IP 주소 - Routing Table|2
2-->|다음 홉 MAC 주소 - ARP, NDP|1
</div>

</body>
<script>
var config = {
    startOnLoad:true,
    theme: 'forest',
    flowchart:{
            useMaxWidth:false,
            htmlLabels:true
        }
};
mermaid.initialize(config);
window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
</script>

</html>
